import numpy as np
import pandas as pd
import matplotlib as mpl
mpl.rcParams['font.family'] = 'Arial'
import matplotlib.pyplot as plt
from matplotlib.colors import LinearSegmentedColormap
import argparse

parser = argparse.ArgumentParser(description='parse regression output and plot coefficients in heatmap')
parser.add_argument('outputdir', type=str, help='path to top-level output directory')
parser.add_argument('runname', type=str, help='run name used in mlr.py, results are expected in (outputdir)/selectionrate/regression/(runname)/')
args = parser.parse_args()
regression_dir = args.outputdir + '/selectionrate/regression/%s/' % args.runname

def dummy_series(length,index_list,val=0.0):
	# generates a dummy series to be used pad in pad_series() below
	dummy = pd.Series([val for i in range(length)])
	dummy.index = index_list
	return dummy

def pad_series(s,length):
	# for padding 0's on the front of a series when building square correlation-matrix style dataframes for heatmaps
	# these padded values are ultimately masked in the plotting but are required to maintain consistent length of series
	# used to parse an entire term series in parse_term_series() below
	dummy = dummy_series(length,['D' for d in range(length)])
	s = pd.concat([dummy,s])
	return s

def parse_term_series(df,startrow,endrow,padlength,newindex,col="lasso-AIC-coefs"):
	# extracts a series of coefficients for terms defined by startrow and endrow
	# the df needs to be term-sorted (the *-by_terms csv generated by mlr.py)
	# different regression models can be accessed by specifying col=
	new_series = df.loc[startrow:endrow, col]
	new_series = pad_series(new_series,padlength)
	new_series.index = newindex
	return new_series

def parse_model_results(csvfile,model="lasso-AIC-coefs"):
	# takes a csv file listing regression coefficients for various models (produced by mlr.py)
	# returns dataframes structured to make each heatmap of regression coefficients for each group
	# of terms (G, CxG, GxG, and three different CxGxG)
	# the csvfile should be *-by_terms.csv since the order of terms is used to extract the data

	df = pd.read_csv(csvfile, index_col=0)

	# organize the data into separate dataframes for each heatmap
	# ===========================================================

	# single terms (G, C)
	g_series = df.loc["const":"G9", model]
	c_series = df.loc["CE":"CO", model]
	single_terms_series = pd.concat([g_series,c_series])
	single_terms_series.index = ['const','G1','G2/3','G4','G5','G6','G7','G8','G9','CE','CL','CO']
	single_terms_df = pd.DataFrame([single_terms_series]).transpose()

	# CxG terms: CE/CL/CO x G1-G8
	cexg_series = df.loc["CExG1":"CExG9", model]
	clxg_series = df.loc["CLxG1":"CLxG9", model]
	coxg_series = df.loc["COxG1":"COxG9", model]
	# making a new dataframe from these series, with column names CE/CL/CO and row index G1-G9
	g_index_ = ['G1','G2/3','G4','G5','G6','G7','G8','G9']
	for series in [cexg_series, clxg_series, coxg_series]:
		series.index = g_index_
	frame = {'CE':cexg_series, 'CL':clxg_series, 'CO':coxg_series}
	cxg_terms_df = pd.DataFrame(frame)

	# GxG terms
	# build like correlation matrix. will mask the redundant top half when plotting.
	# redundant top half is filled with 0's before masking
	gxg_frame = {}
	gxg_frame['G1'] = parse_term_series(df,"G1xG23R","G1xG9",1,g_index_, col=model)
	gxg_frame['G2/3'] = parse_term_series(df,"G23RxG4","G23RxG9",2,g_index_, col=model)
	gxg_frame['G4'] = parse_term_series(df,"G4xG5","G4xG9",3,g_index_, col=model)
	gxg_frame['G5'] = parse_term_series(df,"G5xG6","G5xG9",4,g_index_, col=model)
	gxg_frame['G6'] = parse_term_series(df,"G6xG7","G6xG9",5,g_index_, col=model)
	gxg_frame['G7'] = parse_term_series(df,"G7xG8","G7xG9",6,g_index_, col=model)
	gxg_frame['G8'] = parse_term_series(df,"G8xG9","G8xG9",7,g_index_, col=model)
	gxg_frame['G9'] = dummy_series(8,g_index_)
	gxg_terms_df = pd.DataFrame(gxg_frame)

	# CxGxG terms
	cexgxg_frame = {}
	cexgxg_frame['G1'] = parse_term_series(df,"CExG1xG23R","CExG1xG9",1,g_index_, col=model)
	cexgxg_frame['G2/3'] = parse_term_series(df,"CExG23RxG4","CExG23RxG9",2,g_index_, col=model)
	cexgxg_frame['G4'] = parse_term_series(df,"CExG4xG5","CExG4xG9",3,g_index_, col=model)
	cexgxg_frame['G5'] = parse_term_series(df,"CExG5xG6","CExG5xG9",4,g_index_, col=model)
	cexgxg_frame['G6'] = parse_term_series(df,"CExG6xG7","CExG6xG9",5,g_index_, col=model)
	cexgxg_frame['G7'] = parse_term_series(df,"CExG7xG8","CExG7xG9",6,g_index_, col=model)
	cexgxg_frame['G8'] = parse_term_series(df,"CExG8xG9","CExG8xG9",7,g_index_, col=model)
	cexgxg_frame['G9'] = dummy_series(8,g_index_)
	cexgxg_terms_df = pd.DataFrame(cexgxg_frame)

	clxgxg_frame = {}
	clxgxg_frame['G1'] = parse_term_series(df,"CLxG1xG23R","CLxG1xG9",1,g_index_, col=model)
	clxgxg_frame['G2/3'] = parse_term_series(df,"CLxG23RxG4","CLxG23RxG9",2,g_index_, col=model)
	clxgxg_frame['G4'] = parse_term_series(df,"CLxG4xG5","CLxG4xG9",3,g_index_, col=model)
	clxgxg_frame['G5'] = parse_term_series(df,"CLxG5xG6","CLxG5xG9",4,g_index_, col=model)
	clxgxg_frame['G6'] = parse_term_series(df,"CLxG6xG7","CLxG6xG9",5,g_index_, col=model)
	clxgxg_frame['G7'] = parse_term_series(df,"CLxG7xG8","CLxG7xG9",6,g_index_, col=model)
	clxgxg_frame['G8'] = parse_term_series(df,"CLxG8xG9","CLxG8xG9",7,g_index_, col=model)
	clxgxg_frame['G9'] = dummy_series(8,g_index_)
	clxgxg_terms_df = pd.DataFrame(clxgxg_frame)

	coxgxg_frame = {}
	coxgxg_frame['G1'] = parse_term_series(df,"COxG1xG23R","COxG1xG9",1,g_index_, col=model)
	coxgxg_frame['G2/3'] = parse_term_series(df,"COxG23RxG4","COxG23RxG9",2,g_index_, col=model)
	coxgxg_frame['G4'] = parse_term_series(df,"COxG4xG5","COxG4xG9",3,g_index_, col=model)
	coxgxg_frame['G5'] = parse_term_series(df,"COxG5xG6","COxG5xG9",4,g_index_, col=model)
	coxgxg_frame['G6'] = parse_term_series(df,"COxG6xG7","COxG6xG9",5,g_index_, col=model)
	coxgxg_frame['G7'] = parse_term_series(df,"COxG7xG8","COxG7xG9",6,g_index_, col=model)
	coxgxg_frame['G8'] = parse_term_series(df,"COxG8xG9","COxG8xG9",7,g_index_, col=model)
	coxgxg_frame['G9'] = dummy_series(8,g_index_)
	coxgxg_terms_df = pd.DataFrame(coxgxg_frame)

	return (single_terms_df, cxg_terms_df, gxg_terms_df, cexgxg_terms_df, clxgxg_terms_df, coxgxg_terms_df)


# main script:
#==============

# fetch the data
model_file =  '%s/%s-allmodels-by_terms.csv' % (regression_dir, args.runname)
model="lasso-AIC-coefs"

model_dfs = parse_model_results(model_file, model) # tup of dfs: (single, cxg, gxg, cexgxg, clxgxg, coxgxg)

# set up axes
axd = plt.figure(constrained_layout=False, figsize=(9.25,3)).subplot_mosaic(
	"""
	ABCDEFG
	""",
	width_ratios=[1,3,7,7,7,7,0.75],
)
cbar_ax = axd['G']

# aesthetics parameters
cmap = LinearSegmentedColormap.from_list(
    name='test', 
    colors=['#c51b7d','#c51b7d','white','#276419','#276419']
)
vmin=-2.5
vmax=2.5
subtitlefontsize = 10
tickfontsize = 8

subtitles = ['','CxG','GxG','CExGxG','CLxGxG','COxGxG']

# plot each heatmap 
axis_list = [axd[name] for name in ['A','B','C','D','E','F']]
for (ax_i, axis) in enumerate(axis_list):

	# mask the GxG and CxGxG:
	if ax_i > 1 and ax_i != 6 and ax_i != 7:
		mask = np.triu(np.ones_like(model_dfs[ax_i], dtype=bool))
	else:
		mask = None
	g = sns.heatmap(model_dfs[ax_i], mask=mask, ax=axis, center=0, cmap=cmap, square=True, linewidths=1.5, vmin=vmin, vmax=vmax, cbar_ax=cbar_ax) # cbar_kws=dict(pad=0.01,shrink=0.55)
	axis.set_title(subtitles[ax_i], fontsize=subtitlefontsize)
	axis.tick_params(left=False, bottom=False)

	# axis-specific tick label customization
	if ax_i in [0,6]: # single terms
		g.set_xticklabels(g.get_xmajorticklabels(), fontsize = tickfontsize)
		g.set_yticklabels(g.get_ymajorticklabels(), fontsize = tickfontsize)
		axis.set_xticks([0.5])
		axis.set_xticklabels([''])
		axis.set_yticks([0.5,1.5,2.5,3.5,4.5,5.5,6.5,7.5,8.5,9.5,10.5,11.5])
		axis.set_yticklabels(['const','G1','G2/3','G4','G5','G6','G7','G8','G9','CE','CL','CO'])
	elif ax_i in [1,7]: # CxG terms
		g.set_xticklabels(g.get_xmajorticklabels(), fontsize = tickfontsize)
		g.set_yticklabels(g.get_ymajorticklabels(), fontsize = tickfontsize)
		axis.set_xticks([0.5,1.5,2.5])
		axis.set_xticklabels(['CE','CL','CO'], rotation = 90)
	elif ax_i in [2,3,4,5,8,9,10,11]: # GxG and CxGxG:
		g.set_xticklabels(g.get_xmajorticklabels(), fontsize = tickfontsize)
		g.set_yticklabels(g.get_ymajorticklabels(), fontsize = tickfontsize)
		axis.set_xticks([0.5,1.5,2.5,3.5,4.5,5.5,6.5])
		axis.set_xticklabels(['G1','G2/3','G4','G5','G6','G7','G8'], rotation = 90)
		axis.set_yticks([1.5,2.5,3.5,4.5,5.5,6.5,7.5])
		axis.set_yticklabels(['G2/3','G4','G5','G6','G7','G8','G9'])

cbar_ax.tick_params(labelsize=tickfontsize)
plt.tight_layout()
plt.savefig("%s/%s_coefs_summary.pdf" % (regression_dir, model))
plt.savefig("%s/%s_coefs_summary.png" % (regression_dir, model))

